#pragma once

#include "lexer.h"
#include "type.h"



typedef struct Env Env;
typedef struct Sym Sym;

typedef struct Expr Expr;
typedef struct Stmt Stmt;
typedef struct Ast Ast;
typedef struct TypeSpec TypeSpec;

typedef enum TypeSpecKind {
    type_spec_none,
    type_spec_name,
    type_spec_func,
    type_spec_ptr,
    type_spec_array,
} TypeSpecKind ;


struct TypeSpec {
    Loc          location;
    TypeSpecKind kind;
    union {
        String name;
        struct {
            TypeSpec** args;
            TypeSpec* ret_type;
        } func;
        struct {
            TypeSpec* base;
        } ptr;
        struct {
            TypeSpec* base;
            u64       length;
        } array;
    };
};

typedef enum DeclKind {
    decl_import,
    decl_var,
    decl_const,
    decl_func,
    decl_struct,
    decl_union,
    decl_enum,
} DeclKind;


typedef struct Argument {
    Loc         location;
    String      name;
    TypeSpec*   type;
} Argument;

typedef Argument Member;

typedef struct EnumItem {
    Loc         location;
    String      name;
} EnumItem;

typedef struct Decl {
    Loc         location;
    DeclKind    kind;
    String      name;
    Type*       type;

    // used to store the the scope created by function decls
    Env*        scope;

    union {
        struct {
            TypeSpec*   type;
            Expr*       value;
            b8          is_extern;
        } var;
        struct {
            Argument*   args;
            TypeSpec*   ret_type;
            Stmt**      body;
            b8          is_extern;
        } func;
        struct {
            Member*     members;
        } compound;
        struct {
            TypeSpec*   type;
            EnumItem*   items;
        } enum_decl;
    };
} Decl;



typedef enum StmtKind {
    stmt_expr,
    stmt_decl,
    stmt_if,
    stmt_for,
    stmt_while,
    stmt_block,
    stmt_assign,
    stmt_break,
    stmt_continue,
    stmt_return,
    stmt_defer,
} StmtKind;


typedef struct IfStmt {
    Env*    scope; // scope created by the if statement.
    Expr*   cond;
    Stmt**  then;
} IfStmt;


struct Stmt {
    StmtKind kind;
    Loc      location;

    // the scope created by the statment. it's null for 
    // statements that doesn't need to create their own 
    // scopes.
    // sometimes it's used to store the scope that the
    // the statement defined in.
    Env*     scope; 


    // list of the statements generated by the checker. for example 
    // if the checker encountered a &10 a temp variable must must be 
    // created to hold the 10 value.
    // these generated statements are stored so we can make sure we 
    // generate them before the actual statement.
    Stmt** generated_stmts; 

    union {
        Decl    decl;    
        Expr*   expr;
        Stmt*   defer;
        struct {
            Stmt* init;
            Expr* cond;
            Stmt* post;
            Stmt** body;
        } for_stmt;
        struct {
            Expr*   cond;
            Stmt**  body;
        } while_stmt;
        struct {
            IfStmt*  if_stmt;
            IfStmt** else_ifs;
            Stmt**   else_stmt;
            Env*     else_scope;
        } if_stmt;
        struct {
            Expr*   lhs;
            Expr*   rhs;
            u8      op;
        } assign;
        struct {
            Stmt** body;
        } block;
    };
};


typedef enum ExprKind {
    expr_none,
    expr_name,
    expr_int,
    expr_float,
    expr_str,
    expr_cast,
    expr_ternary,
    expr_binary,
    expr_unary,
    expr_member,
    expr_index,
    expr_call,
    expr_compound,
    expr_init_list,
    expr_typeid_type,
    expr_typeid_expr,
    expr_sizeof_type,
    expr_sizeof_expr,
} ExprKind;


typedef struct StructInitItem {
    Loc     location;
    String  name;
    Expr*   expr;
} StructInitItem;


struct Expr {
    ExprKind kind;
    Loc      location;
    Type*    type;
    union {
        u64        integer;
        f64        float_lit;
        String     name;
        Expr*      expr;
        struct {
            Expr*   cond;
            Expr*   then_expr;
            Expr*   else_expr;
        } ternary;
        struct {
            Expr*     expr;
            TypeSpec* type;
        } type_id;
        struct {
            u8        op;
            Expr*     lhs;
            Expr*     rhs;
        } binary;
        struct {
            u8        op;
            Expr*     expr;
        } unary;
        struct {
            Expr*     callee;
            Expr**    params;
        } call;
        struct {
            Expr*     expr;
            String    name;
        } member;
        struct {
            Expr*     expr;
            Expr*     index;
        } index;
        struct {
            Expr*     expr;
            TypeSpec* type;
        } cast;
        struct {
            String          name;
            StructInitItem* items;
        } compound;
        struct {
            Expr** items;
        } init_list;
    };
};


typedef struct Module {
    Stmt**  statements;
    Env**   scopes;

    // list of the ordered syms generated by the checker.
    Sym**   ordered_syms;

    // contains all the literal strings in the program
    u8*     string_table;

    // all the types in the module/file.
    // used to generate runtime type informations.
    Type**   types;
} Module;


Expr* expr_none_init();
Expr* expr_name_init(Loc location, String name);
Expr* expr_int_init(Loc location, u64 value);
Expr* expr_float_init(Loc location, f64 value);
Expr* expr_str_init(Loc location, String value);
Expr* expr_ternary_init(Loc location, Expr* cond, Expr* then_expr, Expr* else_expr);
Expr* expr_binary_init(Loc location, u8 op, Expr* lhs, Expr* rhs);
Expr* expr_unary_init(Loc location, u8 op, Expr* expr);
Expr* expr_call_init(Loc location, Expr* callee, Expr** params);
Expr* expr_compound_init(Loc location, String name, StructInitItem* items);
Expr* expr_member_init(Loc location, Expr* expr, String name);
Expr* expr_index_init(Loc location, Expr* expr, Expr* index);
Expr* expr_init_list_init(Loc location, Expr** items);
Expr* expr_cast_init(Loc location, Expr* expr, TypeSpec* type);
Expr* expr_typeid_expr_init(Loc location, Expr* expr);
Expr* expr_typeid_type_init(Loc location, TypeSpec* type);
Expr* expr_sizeof_expr_init(Loc location, Expr* expr);
Expr* expr_sizeof_type_init(Loc location, TypeSpec* type);


TypeSpec* type_spec_none_init();
TypeSpec* type_spec_name_init(Loc location, String name);
TypeSpec* type_spec_func_init(Loc location, TypeSpec** args, TypeSpec* ret_type);
TypeSpec* type_spec_ptr_init(Loc location, TypeSpec* base);
TypeSpec* type_spec_array_init(Loc location, TypeSpec* base, u64 length);


IfStmt* if_init(Expr* cond, Stmt** then);
Stmt*   stmt_import_decl_init(Loc location, String name);
Stmt*   stmt_var_decl_init(Loc location, String name, TypeSpec* type, Expr* expr);
Stmt*   stmt_const_decl_init(Loc location, String name, TypeSpec* type, Expr* expr);
Stmt*   stmt_func_decl_init(Loc location, String name, Argument* args, TypeSpec* ret_type, Stmt** body);
Stmt*   stmt_struct_decl_init(Loc location, String name, Member* items);
Stmt*   stmt_union_decl_init(Loc location, String name, Member* items);
Stmt*   stmt_enum_decl_init(Loc location, String name, EnumItem* items, TypeSpec* type);
Stmt*   stmt_for_init(Stmt* init, Expr* cond, Stmt* post, Stmt** body);
Stmt*   stmt_while_init(Expr* cond, Stmt** body);
Stmt*   stmt_block_init(Stmt** body);
Stmt*   stmt_if_init(IfStmt* if_stmt, IfStmt** else_ifs, Stmt** else_stmt);
Stmt*   stmt_assign_init(Loc location, u8 op, Expr* lhs, Expr* rhs);
Stmt*   stmt_expr_init(Expr* expr);
Stmt*   stmt_break_init();
Stmt*   stmt_continue_init();
Stmt*   stmt_return_init(Expr* return_expr);
Stmt*   stmt_defer_init(Stmt* defered);


inline EnumItem enum_item_from_token(Token token) {
    EnumItem item;
    item.location = token.location;
    item.name = token.string;

    return item;
}

void print_stmt(Stmt* stmt, u32 level, b8 is_last, b8 add_spaces);
void print_type_spec(TypeSpec* spec);
void print_expr(Expr* expr, u32 level, b8 is_last);
void print_module(Module* module);

